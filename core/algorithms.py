# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SecInterp
                                 A QGIS plugin
 Data extraction for geological interpretation
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-11-15
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Juan M Bernales
        email                : juanbernales@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import traceback
from pathlib import Path

from qgis.PyQt.QtCore import (
    QCoreApplication,
    QSettings,
    QTranslator,
)
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDialogButtonBox, QMessageBox

from qgis.core import (
    QgsRaster,
    QgsRasterLayer,
    QgsVectorLayer,
    QgsWkbTypes,
)

from ..gui.main_dialog import SecInterpDialog
from ..gui.preview_renderer import PreviewRenderer
from . import utils as scu
from . import validation as vu
from sec_interp.logger_config import get_logger
from ..exporters import (
    CSVExporter,
    ProfileLineShpExporter,
    GeologyShpExporter,
    StructureShpExporter,
    AxesShpExporter,
)


logger = get_logger(__name__)


class SecInterp:
    """QGIS Plugin Implementation for Geological Data Extraction.

    This class implements the main logic of the SecInterp plugin, handling
    initialization, UI integration, and orchestration of data processing tasks.
    It connects the QGIS interface with the plugin's dialog and processing algorithms.
    """

    def __init__(self, iface):
        """Constructor.

        Args:
            iface (QgsInterface): An interface instance that will be passed to this class
                which provides the hook by which you can manipulate the QGIS
                application at run time.
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = Path(__file__).resolve().parent
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = self.plugin_dir / f"i18n/SecInterp_{locale}.qm"

        if locale_path.exists():
            self.translator = QTranslator()
            self.translator.load(str(locale_path))
            QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = SecInterpDialog(self.iface, self)

        # Initialize preview renderer (canvas will be set in run())
        self.preview_renderer = PreviewRenderer()
        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Sec Interp")
        # Create custom toolbar and make it visible
        self.toolbar = self.iface.addToolBar("Sec Interp")
        self.toolbar.setObjectName("SecInterp")
        self.toolbar.setVisible(True)  # Ensure toolbar is visible

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        Args:
            message (str): String for translation.

        Returns:
            str: Translated string (or original if no translation found).
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("SecInterp", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        Args:
            icon_path (str): Path to the icon for this action.
            text (str): Text that should be shown in menu items for this action.
            callback (function): Function to be called when the action is triggered.
            enabled_flag (bool): A flag indicating if the action should be enabled
                by default. Defaults to True.
            add_to_menu (bool): Flag indicating whether the action should also
                be added to the menu. Defaults to True.
            add_to_toolbar (bool): Flag indicating whether the action should also
                be added to the toolbar. Defaults to True.
            status_tip (str): Optional text to show in a popup when mouse pointer
                hovers over the action.
            whats_this (str): Optional text to show in the status bar when the
                mouse pointer hovers over the action.
            parent (QWidget): Parent widget for the new action. Defaults None.

        Returns:
            QAction: The action that was created. Note that the action is also
                added to self.actions list.
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Add to custom toolbar
            self.toolbar.addAction(action)
            # Also add to Plugins toolbar for visibility
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # Use absolute path to icon file to ensure it loads in toolbar
        icon_path = str(self.plugin_dir.parent / "icon.png")
        self.add_action(
            icon_path,
            text=self.tr("Geological data extraction"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Sec Interp"), action)
            self.iface.removeToolBarIcon(action)
        
        # Remove custom toolbar
        if self.toolbar:
            del self.toolbar
            self.toolbar = None

    def run(self):
        """Run method that performs all the real work.

        This method initializes the dialog, connects signals and slots,
        and executes the main event loop for the plugin dialog.
        """

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the
        # plugin is started
        if self.first_start is True:
            self.first_start = False
            self.dlg = SecInterpDialog(self.iface, self)
            # Update preview renderer with the new dialog's canvas
            self.preview_renderer.canvas = self.dlg.preview
        # show the dialog
        self.dlg.show()

        # Disconnect default accepted signal to prevent closing on Save
        try:
            self.dlg.button_box.accepted.disconnect()
        except TypeError:
            pass

        # Connect OK button to process and close
        self.dlg.button_box.button(QDialogButtonBox.Ok).clicked.connect(
            self.process_data
        )
        self.dlg.button_box.button(QDialogButtonBox.Ok).clicked.connect(self.dlg.accept)

        # Connect Save button to save only
        self.dlg.button_box.button(QDialogButtonBox.Save).clicked.connect(
            self.save_profile_line
        )
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def _get_and_validate_inputs(self):
        """Retrieve and validate inputs from the dialog.

        Returns:
            dict: Validated inputs including layer objects, or None if validation fails.
        """
        # Get values from the dialog using the helper method
        values = self.dlg.get_selected_values()

        is_valid, error_msg, validated_values = vu.validate_and_get_layers(values)

        if not is_valid:
            scu.show_user_message(self.dlg, self.tr("Error"), self.tr(error_msg))
            return None

        return validated_values

    def process_data(self):
        """Main data processing method triggered by the OK button.

        This method orchestrates the entire data extraction workflow:
        1. Validates user inputs (layers, fields, parameters).
        2. Generates the topographic profile.
        3. Generates the geological profile (if selected).
        4. Projects structural data onto the section (if selected).
        5. Updates the results text area.
        6. Draws the interactive preview.

        Handles various exceptions and displays appropriate error messages to the user.
        """
        try:
            # Get and validate inputs
            inputs = self._get_and_validate_inputs()
            if not inputs:
                return

            # Extract values for easier access
            values = inputs
            raster_layer = inputs["raster_layer_obj"]
            line_layer = inputs["line_layer_obj"]
            outcrop_layer = inputs["outcrop_layer_obj"]
            structural_layer = inputs["structural_layer_obj"]

            selected_band = values["selected_band"]
            buffer_dist = values["buffer_distance"]

            # Process topographic profile
            profile_data = self.topographic_profile(
                line_layer, raster_layer, selected_band
            )

            # Validate profile data was generated
            if not profile_data:
                scu.show_user_message(
                    self.dlg,
                    self.tr("Error"),
                    self.tr(
                        "No profile data was generated. Check that the line intersects the raster."
                    ),
                )
                return

            # Initialize data containers
            geol_data = None
            struct_data = None

            # Initialize result text
            result_text = f"‚úì Data processed successfully!\n\nTopography: {len(profile_data)} points"
            self.dlg.results.setPlainText(result_text)

            # Process outcrop data
            if outcrop_layer:
                outcrop_name_field = values["outcrop_name_field"]
                if outcrop_name_field:
                    geol_data = self.geol_profile(
                        line_layer,
                        raster_layer,
                        outcrop_layer,
                        outcrop_name_field,
                        selected_band,
                    )

                    if geol_data:
                        result_text += f"\nGeology: {len(geol_data)} points"
                        self.dlg.results.setPlainText(result_text)
                    else:
                        result_text += "\nGeology: No intersections"
                        self.dlg.results.setPlainText(result_text)
                else:
                    result_text += (
                        "\n‚ö† Outcrop layer selected but no geology field specified."
                    )
                    self.dlg.results.setPlainText(result_text)

            # Process structural data
            if structural_layer:
                dip_field = values["dip_field"]
                strike_field = values["strike_field"]

                if dip_field and strike_field:
                    # Get the azimuth of the cross-section line
                    line_feat = next(line_layer.getFeatures(), None)
                    if not line_feat:
                        scu.show_user_message(
                            self.dlg,
                            self.tr("Error"),
                            self.tr("Line layer has no features."),
                        )
                        return

                    line_geom = line_feat.geometry()
                    if not line_geom or line_geom.isNull():
                        scu.show_user_message(
                            self.dlg,
                            self.tr("Error"),
                            self.tr("Line geometry is not valid."),
                        )
                        return

                    line_azimuth = scu.calculate_line_azimuth(line_geom)

                    struct_data = self.project_structures(
                        line_layer,
                        structural_layer,
                        buffer_dist,
                        line_azimuth,
                        dip_field,
                        strike_field,
                    )

                    if struct_data:
                        result_text += f"\nStructures: {len(struct_data)} points"
                        self.dlg.results.setPlainText(result_text)
                    else:
                        result_text += f"\nStructures: None in {buffer_dist}m buffer"
                        self.dlg.results.setPlainText(result_text)
                else:
                    result_text += "\n‚ö† Structural layer selected but dip/strike fields not specified."
                    self.dlg.results.setPlainText(result_text)

            # Draw preview with all data
            logger.debug("About to draw preview:")
            logger.debug(
                "  - profile_data: %d points", len(profile_data) if profile_data else 0
            )
            logger.debug("  - geol_data: %d points", len(geol_data) if geol_data else 0)
            logger.debug(
                "  - struct_data: %d points", len(struct_data) if struct_data else 0
            )
            self.draw_preview(profile_data, geol_data, struct_data)

            result_text += (
                "\n\nüí° Use 'Save' button to export data to CSV and Shapefile."
            )
            self.dlg.results.setPlainText(result_text)

        except (IOError, OSError) as e:
            # File system errors (temp file creation, permissions, etc.)
            scu.show_user_message(
                self.dlg,
                self.tr("File System Error"),
                self.tr(
                    f"Failed to access temporary files: {str(e)}\n\n"
                    f"Please check disk space and permissions."
                ),
                "error",
            )
            self.dlg.results.append(f"File system error: {str(e)}")
            logger.error("File system error in process_data: %s", str(e), exc_info=True)

        except ValueError as e:
            # Data validation errors (invalid geometry, empty data, etc.)
            scu.show_user_message(
                self.dlg,
                self.tr("Data Validation Error"),
                self.tr(
                    f"Invalid data encountered: {str(e)}\n\n"
                    f"Please verify your input layers and try again."
                ),
            )
            self.dlg.results.append(f"Validation error: {str(e)}")
            logger.error("Validation error in process_data: %s", str(e), exc_info=True)

        except RuntimeError as e:
            # Runtime errors (geometry operations, CRS transformations, etc.)
            scu.show_user_message(
                self.dlg,
                self.tr("Processing Error"),
                self.tr(
                    f"Error during data processing: {str(e)}\n\n"
                    f"This may be due to invalid geometries or CRS issues."
                ),
            )
            self.dlg.results.append(f"Processing error: {str(e)}")
            logger.error("Runtime error in process_data: %s", str(e), exc_info=True)

        except KeyError as e:
            # Missing field or attribute errors
            scu.show_user_message(
                self.dlg,
                self.tr("Field Error"),
                self.tr(
                    f"Required field not found: {str(e)}\n\n"
                    f"Please verify that all required fields exist in your layers."
                ),
            )
            self.dlg.results.append(f"Field error: {str(e)}")
            logger.error("Field error in process_data: %s", str(e), exc_info=True)

        except Exception as e:
            # Catch-all for unexpected errors
            import traceback

            error_details = traceback.format_exc()
            scu.show_user_message(
                self.dlg,
                self.tr("Unexpected Error"),
                self.tr(
                    f"An unexpected error occurred: {str(e)}\n\nDetails:\n{error_details}"
                ),
                "error",
            )
            self.dlg.results.append(f"Unexpected error: {str(e)}")
            logger.error("Unexpected error in process_data: %s", error_details)

    def topographic_profile(
        self,
        line_lyr: QgsVectorLayer,
        raster_lyr: QgsRasterLayer,
        band_number: int = 1,
    ):
        """Generate topographic profile data by sampling elevation along the section line.

        This function returns the profile data as a list of tuples.

        Args:
            line_lyr (QgsVectorLayer): The cross-section line layer.
            raster_lyr (QgsRasterLayer): The DEM/raster layer for elevation.
            band_number (int): Raster band to sample (default: 1).

        Returns:
            list: List of (distance, elevation) tuples.

        Raises:
            ValueError: If line layer has no features or invalid geometry.
        """
        line_feat = next(line_lyr.getFeatures(), None)
        if not line_feat:
            raise ValueError("Line layer has no features")

        geom = line_feat.geometry()
        if not geom or geom.isNull():
            raise ValueError("Line geometry is not valid")

        da = scu.create_distance_area(line_lyr.crs())

        # Sample points using helper
        # For topographic profile, we measure from the start of the line
        points = scu.sample_elevation_along_line(geom, raster_lyr, band_number, da)

        # Convert QgsPointXY to tuples
        values = [(round(p.x(), 1), round(p.y(), 1)) for p in points]

        return values

    def geol_profile(
        self,
        line_lyr: QgsVectorLayer,
        raster_lyr: QgsRasterLayer,
        outcrop_lyr: QgsVectorLayer,
        glg_field: str,
        band_number: int = 1,
    ):
        """Generate geological profile data by intersecting the section line with outcrop polygons.

        This function returns the profile data as a list of tuples.

        Args:
            line_lyr (QgsVectorLayer): The cross-section line layer.
            raster_lyr (QgsRasterLayer): The DEM/raster layer for elevation.
            outcrop_lyr (QgsVectorLayer): The geological outcrop layer (polygons).
            glg_field (str): The field name in outcrop_lyr containing unit names.
            band_number (int): Raster band to sample (default: 1).

        Returns:
            list: List of (distance, elevation, unit_name) tuples.

        Raises:
            ValueError: If line layer has no features or invalid geometry.
        """
        line_feat = next(line_lyr.getFeatures(), None)
        if not line_feat:
            raise ValueError("Line layer has no features")

        line_geom = line_feat.geometry()
        if not line_geom or line_geom.isNull():
            raise ValueError("Line geometry is not valid")

        if line_geom.isMultipart():
            line_start = line_geom.asMultiPolyline()[0][0]
        else:
            line_start = line_geom.asPolyline()[0]

        crs = line_lyr.crs()
        da = scu.create_distance_area(crs)

        values = []

        for feature in outcrop_lyr.getFeatures():
            outcrop_geom = feature.geometry()
            if not outcrop_geom or outcrop_geom.isNull():
                continue

            if not outcrop_geom.intersects(line_geom):
                continue

            intersection = outcrop_geom.intersection(line_geom)
            if not intersection or intersection.isNull():
                continue

            # Handle multi-part geometries if necessary (though intersection usually returns simpler geoms)
            if intersection.isMultipart():
                geoms = intersection.asGeometryCollection()
            else:
                geoms = [intersection]

            for geom in geoms:
                if geom.wkbType() not in [
                    QgsWkbTypes.LineString,
                    QgsWkbTypes.LineString25D,
                ]:
                    continue

                dist_step = scu.calculate_step_size(geom, raster_lyr)
                length = geom.length()
                current_dist = 0.0

                while current_dist <= length:
                    pt = geom.interpolate(current_dist).asPoint()

                    # Calculate distance from the start of the original section line
                    dist_from_start = da.measureLine(line_start, pt)

                    # Get elevation
                    res = (
                        raster_lyr.dataProvider()
                        .identify(pt, QgsRaster.IdentifyFormatValue)
                        .results()
                    )
                    elev = res.get(band_number, 0.0)  # Use .get() to avoid KeyError

                    # Get geology
                    glg_val = feature[glg_field]

                    values.append((round(dist_from_start, 1), round(elev, 1), glg_val))

                    current_dist += dist_step

        # Sort values by distance
        values.sort(key=lambda x: x[0])

        return values

    def project_structures(
        self,
        line_lyr: QgsVectorLayer,
        struct_lyr: QgsVectorLayer,
        buffer_m: int,
        line_az: float,
        dip_field: str,
        strike_field: str,
    ):
        """Project structural measurements onto the cross-section plane.

        This function returns the profile data as a list of tuples.

        Filters structures within a buffer distance of the section line and calculates
        their apparent dip in the direction of the section.

        Args:
            line_lyr (QgsVectorLayer): The cross-section line layer.
            struct_lyr (QgsVectorLayer): The structural measurements layer (points).
            buffer_m (int): Buffer distance in meters to include structures.
            line_az (float): Azimuth of the section line in degrees.
            dip_field (str): Field name for dip angle.
            strike_field (str): Field name for strike angle.

        Returns:
            list: List of (distance, apparent_dip) tuples.

        Raises:
            ValueError: If line layer has no features or invalid geometry.
        """

        # Logging: Initial setup
        logger.info("=" * 60)
        logger.info("PROJECT_STRUCTURES - Starting analysis")
        logger.info("=" * 60)
        logger.info(f"Buffer distance: {buffer_m} (units depend on CRS)")
        logger.info(f"Line azimuth: {line_az:.2f}¬∞")
        logger.info(f"Dip field: '{dip_field}'")
        logger.info(f"Strike field: '{strike_field}'")

        line_feat = next(line_lyr.getFeatures(), None)
        if not line_feat:
            raise ValueError("Line layer has no features")

        line_geom = line_feat.geometry()
        if not line_geom or line_geom.isNull():
            raise ValueError("Line geometry is not valid")

        if line_geom.isMultipart():
            line_start = line_geom.asMultiPolyline()[0][0]
        else:
            line_start = line_geom.asPolyline()[0]

        buffer_geom = line_geom.buffer(buffer_m, 25)
        crs = struct_lyr.crs()

        # Logging: CRS information
        logger.info(f"Structural layer CRS: {crs.authid()} - {crs.description()}")
        logger.info(f"CRS units: {crs.mapUnits()}")
        if crs.isGeographic():
            logger.warning(
                "‚ö†Ô∏è  CRS is GEOGRAPHIC (lat/lon) - buffer is in DEGREES, not meters!"
            )
            logger.warning(
                f"   A buffer of {buffer_m} degrees ‚âà {buffer_m * 111} km at equator"
            )
        else:
            logger.info(f"‚úì CRS is PROJECTED - buffer is in map units")

        da = scu.create_distance_area(crs)

        # Logging: Count total features
        total_features = struct_lyr.featureCount()
        logger.info(f"Total features in structural layer: {total_features}")

        projected_structs = []

        # Detailed counters for logging
        null_geom_count = 0
        outside_buffer_count = 0
        missing_field_count = 0
        strike_parse_fail_count = 0
        dip_parse_fail_count = 0
        strike_range_fail_count = 0
        dip_range_fail_count = 0
        success_count = 0

        for idx, f in enumerate(struct_lyr.getFeatures()):
            struct_geom = f.geometry()
            if not struct_geom or struct_geom.isNull():
                null_geom_count += 1
                continue

            if struct_geom.intersects(buffer_geom):
                p = struct_geom.asPoint()
                dist = da.measureLine(line_start, p)

                try:
                    strike_raw = f[strike_field]
                    dip_raw = f[dip_field]
                except KeyError as e:
                    missing_field_count += 1
                    logger.debug(f"Feature {idx}: Missing field {e}")
                    continue

                # Parse strike (supports field notation like "N 15¬∞ W" or numeric)
                strike = scu.parse_strike(strike_raw)
                if strike is None:
                    strike_parse_fail_count += 1
                    logger.debug(
                        f"Feature {idx}: Failed to parse strike '{strike_raw}'"
                    )
                    continue

                # Parse dip (supports field notation like "22¬∞ SW" or numeric)
                dip_angle, dip_direction = scu.parse_dip(dip_raw)
                if dip_angle is None:
                    dip_parse_fail_count += 1
                    logger.debug(f"Feature {idx}: Failed to parse dip '{dip_raw}'")
                    continue

                # Use dip_angle for calculations
                dip = dip_angle
                # Note: dip_direction could be used for additional validation if needed

                # Validate ranges
                is_valid, error_msg = vu.validate_angle_range(
                    strike, "Strike", 0.0, 360.0
                )
                if not is_valid:
                    strike_range_fail_count += 1
                    logger.debug(
                        f"Feature {idx}: Strike validation failed - {error_msg} (value: {strike})"
                    )
                    continue

                is_valid, error_msg = vu.validate_angle_range(dip, "Dip", 0.0, 90.0)
                if not is_valid:
                    dip_range_fail_count += 1
                    logger.debug(
                        f"Feature {idx}: Dip validation failed - {error_msg} (value: {dip})"
                    )
                    continue

                app_dip = scu.calculate_apparent_dip(strike, dip, line_az)
                projected_structs.append((round(dist, 1), round(app_dip, 1)))
                success_count += 1
                logger.debug(
                    f"Feature {idx}: ‚úì Success - dist={dist:.1f}, strike={strike:.1f}¬∞, dip={dip:.1f}¬∞, app_dip={app_dip:.1f}¬∞"
                )
            else:
                outside_buffer_count += 1

        # Sort by distance
        projected_structs.sort(key=lambda x: x[0])

        # Logging: Summary
        logger.info("-" * 60)
        logger.info("FILTERING SUMMARY:")
        logger.info(f"  Total features processed: {total_features}")
        logger.info(f"  ‚úì Successfully projected: {success_count}")
        logger.info(f"  ‚úó Null/invalid geometry: {null_geom_count}")
        logger.info(f"  ‚úó Outside buffer ({buffer_m} units): {outside_buffer_count}")
        logger.info(f"  ‚úó Missing dip/strike fields: {missing_field_count}")
        logger.info(f"  ‚úó Strike parsing failed: {strike_parse_fail_count}")
        logger.info(f"  ‚úó Dip parsing failed: {dip_parse_fail_count}")
        logger.info(f"  ‚úó Strike out of range: {strike_range_fail_count}")
        logger.info(f"  ‚úó Dip out of range: {dip_range_fail_count}")
        logger.info("-" * 60)

        total_skipped = (
            null_geom_count
            + outside_buffer_count
            + missing_field_count
            + strike_parse_fail_count
            + dip_parse_fail_count
            + strike_range_fail_count
            + dip_range_fail_count
        )

        if total_skipped > 0:
            logger.warning(f"‚ö†Ô∏è  Skipped {total_skipped} structural measurements")
            if outside_buffer_count == total_features - null_geom_count:
                logger.warning("‚ö†Ô∏è  ALL valid features are outside the buffer!")
                logger.warning("   ‚Üí Try increasing the buffer distance")
                logger.warning(
                    "   ‚Üí Check that line and structural layers use the same CRS"
                )

        logger.info("=" * 60)

        return projected_structs

    def save_profile_line(self):
        """Save all profile data to CSV and Shapefile formats by delegating to exporters."""
        try:
            inputs = self._get_and_validate_inputs()
            if not inputs:
                return

            values = inputs
            output_folder = Path(values["output_path"])
            is_valid, error, _ = vu.validate_output_path(str(output_folder))
            if not is_valid:
                scu.show_user_message(self.dlg, self.tr("Error"), self.tr(error))
                return

            self.dlg.results.setPlainText("‚úì Generating data for export...")

            # 1. Generate all data in memory first
            profile_data = self.topographic_profile(
                values["line_layer_obj"],
                values["raster_layer_obj"],
                values["selected_band"],
            )
            if not profile_data:
                scu.show_user_message(
                    self.dlg,
                    self.tr("Error"),
                    self.tr("No profile data generated, cannot save."),
                )
                return

            geol_data = None
            if values["outcrop_layer_obj"] and values["outcrop_name_field"]:
                geol_data = self.geol_profile(
                    values["line_layer_obj"],
                    values["raster_layer_obj"],
                    values["outcrop_layer_obj"],
                    values["outcrop_name_field"],
                    values["selected_band"],
                )

            struct_data = None
            if (
                values["structural_layer_obj"]
                and values["dip_field"]
                and values["strike_field"]
            ):
                line_feat = next(values["line_layer_obj"].getFeatures(), None)
                if line_feat:
                    line_geom = line_feat.geometry()
                    line_azimuth = scu.calculate_line_azimuth(line_geom)
                    struct_data = self.project_structures(
                        values["line_layer_obj"],
                        values["structural_layer_obj"],
                        values["buffer_distance"],
                        line_azimuth,
                        values["dip_field"],
                        values["strike_field"],
                    )

            # 2. Orchestrate saving using exporters
            result_msg = ["‚úì Saving files..."]
            csv_exporter = CSVExporter({})
            line_crs = values["line_layer_obj"].crs()

            # Export Topography
            csv_exporter.export(
                output_folder / "topo_profile.csv",
                {"headers": ["dist", "elev"], "rows": profile_data},
            )
            result_msg.append(f"  - topo_profile.csv")
            ProfileLineShpExporter({}).export(
                output_folder / "profile_line.shp",
                {"profile_data": profile_data, "crs": line_crs},
            )
            result_msg.append(f"  - profile_line.shp")

            # Export Geology
            if geol_data:
                csv_exporter.export(
                    output_folder / "geol_profile.csv",
                    {"headers": ["dist", "elev", "geology"], "rows": geol_data},
                )
                result_msg.append(f"  - geol_profile.csv")
                GeologyShpExporter({}).export(
                    output_folder / "geol_profile.shp",
                    {
                        "line_lyr": values["line_layer_obj"],
                        "raster_lyr": values["raster_layer_obj"],
                        "outcrop_lyr": values["outcrop_layer_obj"],
                        "band_number": values["selected_band"],
                    },
                )
                result_msg.append(f"  - geol_profile.shp")

            # Export Structures
            if struct_data:
                csv_exporter.export(
                    output_folder / "structural_profile.csv",
                    {"headers": ["dist", "apparent_dip"], "rows": struct_data},
                )
                result_msg.append(f"  - structural_profile.csv")
                StructureShpExporter({}).export(
                    output_folder / "structural_profile.shp",
                    {
                        "line_lyr": values["line_layer_obj"],
                        "raster_lyr": values["raster_layer_obj"],
                        "struct_lyr": values["structural_layer_obj"],
                        "dip_field": values["dip_field"],
                        "strike_field": values["strike_field"],
                        "band_number": values["selected_band"],
                        "buffer_distance": values["buffer_distance"],
                        "dip_scale_factor": values["dip_scale_factor"],
                    },
                )
                result_msg.append(f"  - structural_profile.shp")

            # Export Axes
            AxesShpExporter({}).export(
                output_folder / "profile_axes.shp",
                {"profile_data": profile_data, "crs": line_crs},
            )
            result_msg.append(f"  - profile_axes.shp")

            result_msg.append(f"\n‚úì All files saved to:\n{output_folder}")
            self.dlg.results.setPlainText("\n".join(result_msg))
            QMessageBox.information(
                self.dlg,
                self.tr("Success"),
                self.tr(f"All data saved to:\n{output_folder}"),
            )

        except Exception as e:
            scu.show_user_message(
                self.dlg,
                self.tr("Export Error"),
                self.tr(f"Failed to export data: {str(e)}"),
                "error",
            )
            logger.error("Export error in save_profile_line: %s", str(e), exc_info=True)

    def draw_preview(self, topo_data, geol_data=None, struct_data=None):
        """Draw enhanced interactive preview using native PyQGIS renderer.

        Args:
            topo_data: List of (dist, elev) tuples for topographic profile
            geol_data: Optional list of (dist, elev, geology_name) tuples
            struct_data: Optional list of (dist, app_dip) tuples
        """
        logger.debug("draw_preview called with:")
        logger.debug("  - topo_data: %d points", len(topo_data) if topo_data else 0)
        logger.debug("  - geol_data: %d points", len(geol_data) if geol_data else 0)
        logger.debug(
            "  - struct_data: %d points", len(struct_data) if struct_data else 0
        )

        # Store data in dialog for re-rendering when checkboxes change
        self.dlg.current_topo_data = topo_data
        self.dlg.current_geol_data = geol_data
        self.dlg.current_struct_data = struct_data

        # Get preview options from dialog checkboxes
        options = self.dlg.get_preview_options()
        logger.debug("Preview options: %s", options)

        # Filter data based on checkbox states
        filtered_topo = topo_data if options.get("show_topo", True) else None
        filtered_geol = geol_data if options.get("show_geol", True) else None
        filtered_struct = struct_data if options.get("show_struct", True) else None

        logger.debug("Filtered data:")
        logger.debug(
            "  - filtered_topo: %d points", len(filtered_topo) if filtered_topo else 0
        )
        logger.debug(
            "  - filtered_geol: %d points", len(filtered_geol) if filtered_geol else 0
        )
        logger.debug(
            "  - filtered_struct: %d points",
            len(filtered_struct) if filtered_struct else 0,
        )

        # Get vertical exaggeration from dialog

        _, _, vert_exag = vu.validate_numeric_input(
            self.dlg.vertexag.text(),
            field_name="Vertical exaggeration",
            allow_empty=True,
        )
        vert_exag = vert_exag if vert_exag is not None else 1.0
        logger.debug("Vertical exaggeration: %.2f", vert_exag)

        # Render using native PyQGIS
        canvas, layers = self.preview_renderer.render(
            filtered_topo, filtered_geol, filtered_struct, vert_exag
        )

        # Store canvas and layers for export
        self.dlg.current_canvas = canvas
        self.dlg.current_layers = layers

        # Update legend
        if hasattr(self.dlg, "legend_widget"):
            self.dlg.legend_widget.update_legend(self.preview_renderer)

        logger.debug("Preview rendered with %d layers", len(layers) if layers else 0)
